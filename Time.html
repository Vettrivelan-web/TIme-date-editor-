<!DOCTYPE html>
<html lang="ta">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Date Editor (Short)</title>
    <!-- piexifjs library for EXIF manipulation -->
    <script src="https://cdn.jsdelivr.net/npm/piexifjs@1.0.6/piexif.min.js"></script>
    <!-- Embedded CSS -->
    <style>
        /* Basic styling variables */
        :root { --primary: #007bff; --secondary: #28a745; --light: #f8f9fa; --dark: #343a40; --white: #fff; --border: #ccc; }

        /* Basic page setup */
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif; /* Modern system fonts */
            background: var(--light);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            margin: 0;
            color: var(--dark);
            min-height: 95vh; /* Try to fill height */
        }
        /* Main container styling */
        .container {
            background: var(--white);
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            align-items: center; /* Center items inside */
            gap: 20px; /* Space between elements */
            max-width: 500px;
            width: 95%;
            margin-top: 1rem; /* Space from top */
        }
        /* Heading style */
        h1 {
            margin-bottom: 1rem;
            font-size: 1.5em;
            color: var(--dark);
            text-align: center;
        }
        /* Center align labels and buttons */
        label, button, .btn-like {
            display: block; /* Make them block level */
            text-align: center;
            width: fit-content; /* Adjust width to content */
            margin-left: auto; /* Center block elements */
            margin-right: auto;
        }
        /* Button and button-like link styles */
        button, .btn-like {
            background-color: var(--primary);
            color: var(--white);
            padding: 10px 18px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s ease;
            text-decoration: none; /* Remove underline from links styled as buttons */
        }
        button:hover, .btn-like:hover {
            background-color: #0056b3; /* Darker blue on hover */
        }
        /* Hide the actual file input */
        #pInput { display: none; }
        /* Image preview styles */
        #imgPreview {
            max-width: 100%;
            max-height: 250px;
            margin-top: 15px;
            border: 1px solid var(--border);
            border-radius: 4px;
            display: none; /* Hidden initially */
            background-color: #eee; /* Placeholder background */
        }
        /* Date/Time input styling */
        #dtInput {
            padding: 8px;
            border: 1px solid var(--border);
            border-radius: 4px;
            margin-top: 5px;
            width: calc(100% - 18px); /* Adjust width considering padding */
            max-width: 250px;
            display: block; /* Ensure it takes block space */
            margin-left: auto; /* Center input */
            margin-right: auto;
        }
        /* Save button specific styles */
        #sBtn {
            background-color: var(--secondary); /* Green color */
            margin-top: 15px;
            padding: 12px 25px; /* Slightly larger */
            font-size: 1.05em;
            color: var(--white);
        }
        #sBtn:hover {
            background-color: #218838; /* Darker green */
        }
        /* Disabled state for save button */
        #sBtn:disabled {
            background-color: #aaa; /* Grey */
            cursor: not-allowed;
            opacity: 0.7;
        }
        /* Status message styling */
        #statusEl {
            margin-top: 15px;
            font-weight: bold;
            min-height: 1.2em; /* Prevent layout shift */
            font-size: 0.9em;
            text-align: center; /* Center status text */
        }
        /* Download link specific styles */
        #dlLink {
            background-color: #17a2b8; /* Teal color */
            margin-top: 10px;
            display: none; /* Hidden initially */
            color: var(--white); /* Ensure text is white */
        }
        #dlLink:hover {
            background-color: #138496; /* Darker teal */
        }
        /* Helper classes for status message colors */
        .error { color: #dc3545; } /* Red */
        .success { color: #28a745; } /* Green */
        .processing { color: #007bff; } /* Blue */
        .warning { color: #ffc107; } /* Yellow */
    </style>
</head>
<body>

    <h1>Photo Date Editor</h1>

    <div class="container">
        <!-- Upload Section -->
        <label for="pInput" class="btn-like">Upload Photo</label>
        <input type="file" id="pInput" accept="image/jpeg, image/png, image/webp">
        <p id="fName" style="font-size: 0.85em; margin-top: 5px; color: #555; text-align: center;">No file selected.</p>
        <img id="imgPreview" src="#" alt="Preview" />

        <!-- Controls Section -->
        <label for="dtInput" style="margin-top:10px; font-weight: 500;">Select New Date & Time:</label>
        <input type="datetime-local" id="dtInput">
        <button id="sBtn" disabled>Save & Download</button>

        <!-- Status and Download Section -->
        <p id="statusEl"></p>
        <a id="dlLink" class="btn-like"></a>
    </div>

    <!-- Embedded JavaScript -->
    <script>
        // Get references to HTML elements
        const pInput = document.getElementById('pInput');
        const fName = document.getElementById('fName');
        const imgPreview = document.getElementById('imgPreview');
        const dtInput = document.getElementById('dtInput');
        const sBtn = document.getElementById('sBtn');
        const statusEl = document.getElementById('statusEl');
        const dlLink = document.getElementById('dlLink');

        // Global variables to store image data
        let imgDataURL = null;
        let originalFName = 'image.jpg';
        let originalFType = 'image/jpeg';

        // Helper function to update status message and style
        const setStatus = (msg, type = 'info') => {
            statusEl.textContent = msg;
            statusEl.className = type; // Apply class for color styling
        };

        // Helper function to enable/disable save button
        const checkEnableBtn = () => {
            sBtn.disabled = !(imgDataURL && dtInput.value);
        };

        // Function to reset the UI to initial state
        const resetUI = (full = true) => {
            fName.textContent = 'No file selected.';
            imgPreview.style.display = 'none';
            imgPreview.src = "#";
            imgDataURL = null; // Clear image data
            sBtn.disabled = true; // Disable save button
            pInput.value = ''; // Clear file input selection
            dlLink.style.display = 'none'; // Hide download link
            dlLink.removeAttribute('href');
            dlLink.removeAttribute('download');
            if (full) {
                dtInput.value = ''; // Clear date input only on full reset
                setStatus(''); // Clear status message
            }
        };

        // Event listener for file input changes
        pInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            setStatus(''); // Clear previous status
            if (!file) { // If no file selected (user cancelled)
                resetUI(false); // Reset partially, keep date input
                return;
            }

            // Store file details
            originalFType = file.type;
            // Validate file type
            if (!['image/jpeg', 'image/png', 'image/webp'].includes(originalFType)) {
                setStatus('Please select JPEG, PNG, or WebP file.', 'error');
                resetUI(); // Full reset
                return;
            }
            // Warn if not JPEG (best for EXIF)
            if (originalFType !== 'image/jpeg') {
                setStatus('Note: EXIF works best for JPEG.', 'warning');
            }

            originalFName = file.name;
            fName.textContent = `Selected: ${originalFName}`;
            dlLink.style.display = 'none'; // Hide any previous download link

            // Read the file as Data URL
            const reader = new FileReader();
            reader.onload = (ev) => {
                imgDataURL = ev.target.result; // Store the image data
                imgPreview.src = imgDataURL; // Show preview
                imgPreview.style.display = 'block';
                checkEnableBtn(); // Check if save button can be enabled
            };
            reader.onerror = () => {
                setStatus('Cannot read file.', 'error');
                resetUI(); // Full reset on error
            };
            reader.readAsDataURL(file);
        });

        // Event listener for date/time input changes
        dtInput.addEventListener('change', checkEnableBtn);

        // Event listener for save button clicks
        sBtn.addEventListener('click', () => {
            // Ensure data is available
            if (!imgDataURL || !dtInput.value) {
                setStatus('Photo and Date/Time required.', 'error');
                return;
            }
            // Update status and disable button during processing
            setStatus('Processing...', 'processing');
            dlLink.style.display = 'none';
            sBtn.disabled = true;

            // Call the image processing function (returns a Promise)
            processImage(imgDataURL, dtInput.value)
                .then(({ finalDataUrl, finalFileName }) => {
                    // On success, set up the download link
                    dlLink.href = finalDataUrl;
                    dlLink.download = finalFileName;
                    // Show shorter filename in link text if too long
                    const linkText = finalFileName.length > 25 ? `${finalFileName.substring(0,22)}...` : finalFileName;
                    dlLink.textContent = `Download (${linkText})`;
                    dlLink.style.display = 'inline-block'; // Show the link
                    setStatus('Success! Ready to download.', 'success');
                })
                .catch(err => {
                    // On error, show error message
                    console.error("Processing Error:", err); // Log detailed error
                    setStatus(`Error: ${err.message}`, 'error');
                    dlLink.style.display = 'none'; // Ensure link is hidden
                })
                .finally(() => {
                    // Re-enable button if conditions still met
                    checkEnableBtn();
                });
        });

        // --- Core Image Processing Function ---
        function processImage(imageDataUrl, dateTimeString) {
            // Use a Promise for asynchronous operations (image loading)
            return new Promise((resolve, reject) => {
                const img = new Image();
                // When the image is loaded into the Image object
                img.onload = () => {
                    try {
                        // 1. Create a canvas
                        const canvas = document.createElement('canvas');
                        canvas.width = img.naturalWidth; // Set canvas size to image size
                        canvas.height = img.naturalHeight;
                        const ctx = canvas.getContext('2d');

                        // 2. Draw the original image onto the canvas
                        ctx.drawImage(img, 0, 0);

                        // 3. Parse and validate the selected date/time
                        const newDate = new Date(dateTimeString);
                        if (isNaN(newDate)) { // Check if date is valid
                            throw new Error("Invalid Date/Time selected.");
                        }

                        // 4. Format date/time for display on the image (short format)
                        const dispDT = `${newDate.getFullYear()}-${String(newDate.getMonth() + 1).padStart(2, '0')}-${String(newDate.getDate()).padStart(2, '0')} ${String(newDate.getHours()).padStart(2, '0')}:${String(newDate.getMinutes()).padStart(2, '0')}`;

                        // 5. Calculate dynamic padding and font size based on image dimensions
                        const pad = Math.max(8, Math.min(canvas.width, canvas.height) * 0.015); // Padding from edge
                        const fSize = Math.max(10, Math.min(canvas.width, canvas.height) * 0.025); // Font size

                        // 6. Set text style and draw the date/time text on canvas (bottom-right)
                        ctx.font = `bold ${fSize}px sans-serif`; // Font style
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; // White text, slightly transparent
                        ctx.textAlign = 'right'; // Align text to the right
                        ctx.textBaseline = 'bottom'; // Align text to the bottom
                        // Add a shadow for better visibility
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                        ctx.shadowBlur = fSize * 0.15; // Blur relative to font size
                        ctx.shadowOffsetX = 1; // Small offset
                        ctx.shadowOffsetY = 1;
                        // Draw the text
                        ctx.fillText(dispDT, canvas.width - pad, canvas.height - pad);

                        // 7. Export canvas content as JPEG Data URL (best for EXIF)
                        const outMime = 'image/jpeg';
                        const quality = 0.9; // JPEG quality (0.0 to 1.0)
                        const canvasDataUrl = canvas.toDataURL(outMime, quality);

                        // 8. Prepare EXIF data object
                        const y = newDate.getFullYear(), mo = String(newDate.getMonth()+1).padStart(2,'0'), d = String(newDate.getDate()).padStart(2,'0');
                        const h = String(newDate.getHours()).padStart(2,'0'), m = String(newDate.getMinutes()).padStart(2,'0'), s = String(newDate.getSeconds()).padStart(2,'0');
                        // EXIF requires specific format: YYYY:MM:DD HH:MM:SS
                        const exifDT = `${y}:${mo}:${d} ${h}:${m}:${s}`;
                        // Create EXIF structure using piexifjs constants
                        const exifObj = {
                            "0th": {[piexif.ImageIFD.DateTime]: exifDT}, // Main image date tag
                            "Exif": { // Exif specific tags
                                [piexif.ExifIFD.DateTimeOriginal]: exifDT, // Original date/time taken
                                [piexif.ExifIFD.DateTimeDigitized]: exifDT // Date/time digitized
                            },
                            "GPS": {} // Keep GPS empty (we are not modifying it)
                        };
                        // Convert the EXIF object to bytes string
                        const exifBytes = piexif.dump(exifObj);

                        // 9. Insert EXIF data into the JPEG Data URL generated from canvas
                        const finalDataUrl = piexif.insert(exifBytes, canvasDataUrl);

                        // 10. Create a new filename
                        const timestampSuffix = newDate.toISOString().slice(0,19).replace(/[-T:]/g, ''); // Format: YYYYMMDDHHMMSS
                        // Remove old extension and add timestamp + .jpg
                        const baseName = originalFName.substring(0, originalFName.lastIndexOf('.')) || originalFName;
                        const finalFileName = `${baseName}_${timestampSuffix}.jpg`; // Ensure .jpg extension

                        // 11. Resolve the promise with the final data URL and filename
                        resolve({ finalDataUrl, finalFileName });

                    } catch (error) {
                        // If any error occurs during canvas/EXIF processing, reject the promise
                        reject(error);
                    }
                };
                // Handle image loading errors
                img.onerror = () => {
                    reject(new Error("Cannot load image onto canvas. Image might be corrupt or invalid."));
                };
                // Start loading the image from the original Data URL
                img.src = imageDataUrl;
            });
        } // End of processImage function

        // --- Initial Setup ---
        resetUI(); // Reset the UI when the page loads

    </script>

</body>
</html>